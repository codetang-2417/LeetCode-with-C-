# ACM 模式练习题 

## 二分法

### [[NOIP2001]一元三次方程求解](https://ac.nowcoder.com/acm/problem/16694)

题目描述
> 有形如：ax3+bx2+cx+d=0  这样的一个一元三次方程。给出该方程中各项的系数(a，b，c，d  均为实数)，并约定该方程存在三个不同实根(根的范围在-100至100之间)，且根与根之差的绝对值 ≥ 1。要求由小到大依次在同一行输出这三个实根(根与根之间留有空格)，并精确到小数点后2位。
    
> 提示：记方程f(x) = 0，若存在2个数x1和x2，且x1 < x2，f(x1)*f(x2) < 0，则在(x1，x2)之间一定有一个根。

> 输入描述:
    一行，4个实数A,B,C,D。

> 输出描述:
    一行，3个实根，并精确到小数点后2位。
示例1
输入
    1 -5 -4 20
输出
    -2.00 2.00 5.00

分析：题目中点在与根和根之间的差值≥1,且根的范围从[-100,100]，因此需要以1为步长，遍历整个区间。然后当满足条件时，进行二分查找。

需要注意的是，输出答案时，要避免选择错误的值。

```C++
#include<bits/stdc++.h> // 万能头文件

double a,b,c,d;

double equation(double x){
    return a*x*x*x + b*x*x + c*x+ d;
}

int main(){
    std::cin >> a >> b >> c >> d;
    double l,r,m;// 二分查找需要的边界和中间值
    int ret = 0;
    for(int i=-100; i<100;i++){
        if(ret == 3) break;
        if(equation(i) == 0)
        {
            std::cout << std::fixed << std::setprecision(2) << i*1.0 << " ";
            ret++;
        }
        else if(equation(i)*equation(i+1) < 0){// 当符合根条件时，进行二分查找
            l=i,r=i+1;
            while(r-l >= 0.01)
            {
                m = (r+l)/2;
                if(equation(m)*equation(r) <= 0)// 等于0情况出现时，说明根为m,此时右边界r向m点靠拢
                    l = m;
                else
                    r = m;
            }
            std::cout << std::fixed << std::setprecision(2) << (r+l)/2 << " ";// 这里需要注意，输出值应该为中点值，因为存在r和l的小数点后两位相差0.01，但仍满足r-l<0.01，例如：0.124和0.132
            ret++;
        }
    }

    if(equation(100) == 0)
        std::cout << std::fixed << std::setprecision(2) << 100.0;

    return 0;
}

```

### [[NOIP2012]借教室](https://ac.nowcoder.com/acm/problem/16564)


题目描述 

>在大学期间，经常需要租借教室。大到院系举办活动，小到学习小组自习讨论，都需要向学校申请借教室。教室的大小功能不同，借教室人的身份不同，借教室的手续也不一样。  
>面对海量租借教室的信息，我们自然希望编程解决这个问题。
>    
>我们需要处理接下来n天的借教室信息，其中第i天学校有ri个教室可供租借。共有m份订单，每份订单用三个正整数描述，分别为dj, sj, tj，表示某租借者需要从第sj天到第tj天租借教室（包括第sj天和第tj天），每天需要租借dj个教室。  
>   
>我们假定，租借者对教室的大小、地点没有要求。即对于每份订单，我们只需要每天提供dj个教室，而它们具体是哪些教室，每天是否是相同的教室则不用考虑。  
>   
>借教室的原则是先到先得，也就是说我们要按照订单的先后顺序依次为每份订单分配教室。如果在分配的过程中遇到一份订单无法完全满足，则需要停止教室的分配，通知当前申请人修改订单。这里的无法满足指从第sj天到第tj天中有至少一天剩余的教室数量不足dj个。 
>    
>现在我们需要知道，是否会有订单无法完全满足。如果有，需要通知哪一个申请人修改订单。  


>输入描述:
>第一行包含两个正整数n, m，表示天数和订单的数量。  
>第二行包含n个正整数，其中第i个数为ri，表示第i天可用于租借的教室数量。  
>接下来有m行，每行包含三个正整数dj, sj, tj，表示租借的数量，租借开始、结束分别在第几天。  
>每行相邻的两个数之间均用一个空格隔开。天数与订单均用从1开始的整数编号。

> 输出描述:
如果所有订单均可满足，则输出只有一行，包含一个整数0。否则（订单无法完全满足）输出两行，第一行输出一个负整数-1，第二行输出需要修改订单的申请人编号。  

示例1  
输入
```
4 3
2 5 4 3
2 1 3
3 2 4
4 2 4
```

输出
```
-1
2
```
>说明  
第1 份订单满足后，4 天剩余的教室数分别为0，3，2，3。
第2 份订单要求第2 天到第4 天每天提供3 个教室，而第3 天剩余的教室数为2，因此无法满足。分配停止，通知第2个申请人修改订单。
备注:  
对于10%的数据，有1≤n,m≤10；  
对于30%的数据，有1≤n,m≤1000；  
对于70%的数据，有1≤n,m≤105；  
对于100%的数据，有1≤n, m≤106, 0≤ri, dj≤109, 1≤sj≤tj≤ n。  

这道题的典型解法是线段树，但目前不会。  
另一种解法是：**差分**+**二分法**

所谓的**差分**是相对于**前缀和**来讲的。共同点是都需要数组来保存中间计算数据。  

#### 差分数组（Difference Array）

差分数组用于高效地处理数组的区间更新操作。它通过存储相邻元素之间的差值来表示原始数组的变化。假设原始数组为 arr，差分数组为 diff，则差分数组的定义如下：

```
diff[i] = arr[i] - arr[i-1] （i > 0）
diff[0] = arr[0]
```

使用差分数组，可以在 $O(1)$ 的时间内对原始数组的任意区间 [l, r] 进行增量操作，而不必逐个更新区间内的元素。对区间 [l, r] 增加一个值 val，只需将 diff[l] 增加 val，将 diff[r+1] 减去 val。最后，根据差分数组重新计算原始数组即可。

在本题中，每个订单中所需的教室数量就可以看作是差分值，可以根据这个差分值，得到每一天所需要的教室数量。

```cpp
#include <bits/stdc++.h>

int n, m;

const int maxn=1e6+1; // 对于ACM模式来讲，通用做法都是在函数外部开辟大数组，减少程序的运行时间，并且不需要传递参数，更方便
int diff[maxn], need[maxn];// diif即表示差分数组，need是根据差分数组计算得到的每天需要租借的教室数量
int a[maxn], d[maxn];// a表示可以租借的教室数量
int l[maxn], r[maxn];// 每个订单的左右天数边界

bool not_overflow(int index) {
    memset(diff,0,sizeof(diff));// 只有完整的定义才能使用sizeof计算数组大小
    for (int i = 1; i <= index; i++) {// 只计算固定边界中的差分数组，因此后续也只考虑固定边界中的need数组，从而完成二分查找的条件之一：有序性；当每一次都从头开始计算是否满足闲置数量大于租借数量，就能够判断这个过程中是否有不满足条件的情况，如果有不满足，说明这个区间里就有我们需要寻找的订单，因此可以通过二分法紧缩区间，直到最后找到这个订单。
        diff[l[i]] += d[i];// 根据每个订单的开始边界，计算何时增加教室数量
        diff[r[i]+1] -= d[i];// 根据每个订单的结束边界，计算何时减少教室数量，由于需要在租借的再往后一天才能结束，因此加1天
    }

    for (int i = 1; i <= n; i++) {
        need[i] = need[i - 1] + diff[i];// 逆用差分数组，相当于计算前缀和，得到数组每个元素的值，再次计算前缀和，就可以得到真正的前缀和。
        if (need[i] > a[i])//如果供小于求，则说明有订单需要修改，返回false,告知二分过程需要锁紧边界。
            return false;
    }
    return true;
}

int main() {
    std::cin >> n >> m;
    for (int i = 1; i <= n; i++) std::cin >> a[i];
    for (int i = 1; i <= m; i++) std::cin >> d[i] >> l[i] >> r[i];

    int left = 1, right = m;
    int mid;
    if (not_overflow(n)) std::cout << "0"; // 未溢出，则所有订单都满足
    else {
        std::cout << -1 << "\n";
        while (left < right) {
            mid = (left + right) >> 1;
            if (not_overflow(mid)) {// 当订单满足，则左边界left到mid的所有订单都满足，此时收紧左边界
                left = mid+1;
            }
            else{
                right = mid;
            }
        }

        std::cout << left << "\n";
    }

    return 0;
}
```


